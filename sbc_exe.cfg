MEMORY {
# zero page RAM
    # cc65 runtime uses 26 zero page locations. Smallest allowed is $1A
    ZP:        start =    $0, size =  $100, type   = rw, define = yes;

# 65c02 stack is at $100 - $1FF
    RAM:       start =  $200, size = $6800, define = yes;
    STACK:     start = $7000, size = $1000, define = yes;
}

        FEATURES {
            STARTADDRESS:       default = $1000;
        }


SEGMENTS {
#These are in order that they are stacked in memory

# SRAM
    ZEROPAGE:  load = ZP,  type = zp,  define   = yes;
    SBCSTART:  load = RAM, type = ro, start = $0200;
    RODATA:    load = RAM, type = ro;
    # The copydata routine does this - ...how do we not store this twice??
    DATA:      load = RAM,  type = rw,  define = yes;

  #What does this do? Needed by linker...
    ONCE:       load = RAM, type = ro, optional = yes;

    STARTUP:   load = RAM, type = ro;
    INIT:      load = RAM, type = ro, optional = yes;
    CODE:      load = RAM, type = ro;
   # VECTORS:   load = RAM, type = ro,  start    = $FFFA;

#Put these last, they seem to mess up the _init address
    BSS:       load = RAM, type = bss, define   = yes;
    HEAP:      load = RAM, type = bss, optional = yes;


}

FEATURES {
    CONDES:    segment = STARTUP,
                         # initlib
               type    = constructor,
               label   = __CONSTRUCTOR_TABLE__,
               count   = __CONSTRUCTOR_COUNT__;
    CONDES:    segment = STARTUP,
                         # donelib
               type    = destructor,
               label   = __DESTRUCTOR_TABLE__,
               count   = __DESTRUCTOR_COUNT__;
}

# Replaced with STACK: above
#SYMBOLS {
#    # Define the stack size for the application
#        # Heap, if used, needs to know this
#    __STACK_SIZE__:  value = $1000, type = weak;
#}

